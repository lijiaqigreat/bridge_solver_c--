0a1,4
> #include <stdio.h>
> #include <stdlib.h>
> #include "base_type.h"
> #include <time.h>
2,4c6
< #include "optimizer.h"
< 
< int optimize(TypeHintCostB* f,const OptimizeTask* task){
---
> TypeHintCostB optimize(OptimizeTask task,bool debug){
5a8
>     TypeHintCostB f;
8c11
< 
---
>    
10c13
< 
---
>    
20,21c23,24
< 
<     f->cost=task->capCost;
---
>    
>     f.cost=task.capCost;
25,27c28,29
<     int t;
<     for(t=0;t<task->memberSize;++t){
<      bundleLength[0]+=task->length[t];
---
>     for(int t=0;t<task.memberSize;++t){
>         bundleLength[0]+=task.length[t];
32,34c34,36
<     bundleRemain[0]=(TestMask)(1L<<task->memberSize)-1;
<     for(t=0;t<task->typeSize;++t){
<         TestMask valid=bundleRemain[0]&task->typeTestMask[t];
---
>     bundleRemain[0]=(TestMask)(1L<<task.memberSize)-1;
>     for(int t=0;t<task.typeSize;++t){
>         TestMask valid=bundleRemain[0]&task.typeTestMask[t];
40c42
<                 bundleMinCost[0]+=task->length[tmp]*task->cost[t];
---
>                 bundleMinCost[0]+=task.length[tmp]*task.cost[t];
47c49
<     bundleRemain[0]=(TestMask)(1L<<task->memberSize)-1;
---
>     bundleRemain[0]=(TestMask)(1L<<task.memberSize)-1;
55c57
<     for(t=0;t<7;t++){
---
>     for(int t=0;t<7;t++){
59,97d60
<         //TODO don't check when just decreased level?
<        
<         //finished?
<         if(bundleRemain[level]==0){
<             count[1]++;
<             //new best?
<             if(bundleCost[level] < f->cost){
<                 //copy to f
<                 f->cost=bundleCost[level];
<                 for(t=0;t<level;++t){
<                     f->bundle[t]=task->index[bundle[t+1]];
<                 }
<                 for(t=0;t<task->memberSize;++t){
<                     TestMask tmpMask=((TestMask)(1))<<t;
<                     Byte tmp=level-1;
<                     while(TRUE){
<                         if(task->typeTestMask[bundle[tmp+1]]&bundleRemain[tmp]&(tmpMask)){
<                             f->member[t]=tmp;
<                             break;
<                         }
<                         --tmp;
<                     }
<                 }
<             }
<             level-=2;
<             continue;
<         }
<         //stop when cost too large
<         if(bundleCost[level] + bundleMinCost[level] > f->cost){
<             count[2]++;
<             --level;
<             continue;
<         }
<         //stop when bundle total length too small
<         if(level>0 && (bundleLength[level-1] - bundleLength[level] <task->minLength)){
<             count[3]++;
<             --level;
<             continue;
<         }
106c69
<         if(bundle[level+1]==task->typeSize-1){
---
>         if(bundle[level+1]==task.typeSize-1){
111c74
<         
---
>         //TODO don't check when just decreased level?
114c77
<         TestMask valid=bundleRemain[level-1]&task->typeTestMask[bundle[level]];
---
>         TestMask valid=bundleRemain[level-1]&task.typeTestMask[bundle[level]];
122c85
<         bundleCost[level]=bundleCost[level-1]+task->bundleCost;
---
>         bundleCost[level]=bundleCost[level-1]+task.bundleCost;
130,134c93,141
<             int tt=FFSLL(valid)-1;
<             bundleLength[level] -= task->length[tt];
<             bundleCost[level] +=task->cost[bundle[level]]*task->length[tt];
<             bundleMinCost[level]-=task->cost[memberMinIndex[tt]]*task->length[tt];
<             valid^=1L<<tt;
---
>             int t=FFSLL(valid)-1;
>             bundleLength[level] -= task.length[t];
>             bundleCost[level] +=task.cost[bundle[level]]*task.length[t];
>             bundleMinCost[level]-=task.cost[memberMinIndex[t]]*task.length[t];
>             valid^=1L<<t;
>         }
>        
>         //stop when cost too large
>         if(bundleCost[level] + bundleMinCost[level] > f.cost){
>             count[2]++;
>             --level;
>             continue;
>         }
>         //finished?
>         if(bundleRemain[level]==0){
>             count[1]++;
>             //new best?
>             if(bundleCost[level] < f.cost){
>                 //copy to f
>                 f.cost=bundleCost[level];
>                 for(int t=0;t<level;++t){
>                     f.bundle[t]=task.index[bundle[t+1]];
>                 }
>                 for(int t=0;t<task.memberSize;++t){
>                     TestMask tmpMask=((TestMask)(1))<<t;
>                     Byte tmp=level-1;
>                     while(true){
>                         if(task.typeTestMask[bundle[tmp+1]]&bundleRemain[tmp]&(tmpMask)){
>                             f.member[t]=tmp;
>                             break;
>                         }
>                         --tmp;
>                     }
>                 }
>             }
>             level-=2;
>             continue;
>         }
>         //stop when bundle total length too small
>         if(level>0 && (bundleLength[level-1] - bundleLength[level] <task.minLength)){
>             count[3]++;
>             --level;
>             continue;
>         }
>         
>     }
>     if(debug){
>         for(int t=0;t<7;t++){
>             printf("counter %d:%d\n",t,count[t]);
137c144
<     return 0;
---
>     return f;
